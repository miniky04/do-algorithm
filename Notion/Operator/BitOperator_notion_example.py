bit1 = 0x61
bit2 = 0x62

# 0x = 16진수
# 0b = 2진수

print(hex(bit1 & bit2))  # 0x60 -> and 연산자
print(hex(bit1 | bit2))  # 0x63 -> or 연산자
print(hex(bit1 ^ bit2))  # 0x3 -> 배타적 논리합 xor 연산자
print(hex(bit1 >> 1))  # 0x30 -> 1만큼 오른쪽으로 시프트
print(hex(bit1 << 2))  # 0x184 -> 2만큼 왼쪽으로 시프트

# 1-2 예제
'''
bit1과 bit2에 각각 16진수, 61, 62를 대입합니다.
16진수 61과 62는 2진수로 각각 0110 0001, 0110 0010이 됩니다.
'''
print("2진수 61 -> ", bin(0x61))  # 0b1100001
print("2진수 62 -> ", bin(0x62))  # 0b1100010

# 3 예제
'''
0110 0001 & 0110 0010 을 연산하면 0110 0000이 됩니다
이는 16진수로 60이 됩니다.
'''
print("0110 0001 & 0110 0010 -> ", bin(0x61 & 0x62))  # 0b1100000

# 4 예제
'''
0110 0001 | 0110 0010 을 연산하면 0110 0011이 됩니다.
이는 16진수로 63이 됩니다.
'''
print("0110 0001 | 0110 0010 -> ", bin(0x61 | 0x62))  # 0b1100011

# 5 에제
'''
0110 0001 ^ 0110 0010 을 연산하면 0000 0011이 됩니다.
이는 16진수로 3이 됩니다.
배타적 논리합 XOR 은 두개의 비트값이 다른 경우에는 1, 같은 경우에는 0이 됩니다.
'''
print("0110 0001 ^ 0110 0010 -> ", bin(0x61 ^ 0x62))  # 0b11
print("0b11을 16진수로 -> ", hex(0b11))  # 0x3

# 6 예제
'''
0110 0001을 오른쪽으로 1만큼 시프트합니다.
오른쪽으로 시프트하는 경우에는 오른쪽 비트는 없어지고 왼쪽은 최상위 비트로 채워집니다.
결과는 0011 0000이 됩니다.
이는 16진수 값으로 30입니다.
만약 1011 0011 >> 1을 계산하면 시프트하기 전의 원래 값의
최상위 비트가 1이므로 시프트한 결과는 1101 1001이 됩니다.
'''
print("0110 0001 >> 1 -> ", bin(0x61 >> 1))  # 0b110000
print("위의 결과값을 16진수 -> ", hex(0b110000))  # 0x30

print("0110 0011 >> 1 -> ", bin(0x63 >> 1))  # 0b110011 >> 1 => 0b 110 001

# 7 예제
'''
0110 0001을 왼쪽으로 2만큼 시프트합니다.
왼쪽으로 시프트하는 경우에는 1이 시작되기 전까지 왼쪽 비트는 없어지고 오른쪽 비트는 0으로 채워집니다.
즉, 이동하는 왼쪽 비트가 1인 경우에는 그 값이 보존됩니다.
결과는 0001 1000 0100이 됩니다.
이는 16진수 값으로 184입니다.

비트 반전 연산자인 ~은 해당 값의 1의 보수로 비트를 반전시키지만 그 출력값을 이해하려면
2의 보수개념을 알아야하는데 이는 이 책의 범위를 넘기때문에 생략
'''
print("0110 0001 << 2 -> ", bin(0x61 << 2))  # 0b110000100
print("위의 값을 16진수로 -> ", hex(0b110000100))  # 0x184
