링크 : 
https://programmers.co.kr/learn/courses/30/lessons/42840

설명 : 
1. 변수설명 : answer 많이 맞춘 사람수 정열해둘 배열 , count 맞춘 개수 배열 
2. 코드설명 : 
   solution()함수를 정의한 다음, 많이 맞춘 사람 수를 정열해둘 answer라는 변수와 맞춘 개수를 넣어둘 count라는 변수를 생성한다.
`a,b,c가 찍는 방식을 a = [], b = [], c = []식으로 배열정리` 해둔다.
   그 다음 for문을 이용해서 answers(정답)의 개수만큼 반복하는데 이때 i의 값이 0부터 차례대로 들어가게 된다.
   for문 안에 if문을 중첩하게 두고 if a[i % len(a)] == answers[i]: 라는 것은 a[i % a의 길이]가 answers[i]와 똑같을 때 라는 말인데 여기서 i%len(a)를 해주는 이유는
   `a,b,c의 각각의 배열 길이가 다르기 때문이다` 그렇게 조건이 성립하면 count[0] 에 1을 더해준다. 이를 b, c도 반복하며 for 구문이 끝날때까지 반복하게 된다.
   그 다음 count를 tuple형식으로 변환해준다. 변환해준 값이 tuple_count라는 변수에 들어가게 된다. 튜플로 변환해주는 이유는 맞춘개수와 사람을 비교하기 위해서다.
   그 다음 tuple_count를 정렬(sort)해줄 것인데, lambda를 이용해서 정렬을 할 것인데, `key=lambda x: x[1]만 하면 오름차순 정렬이지만, reverse=True를 붙이게 되면 내림차순 정렬`이 된다.
   내림차순 정렬로 정리하는 이유는 맞춘개수가 가장 많은 사람이 제일 앞으로 와야하기 때문이다.
   그 다음 answer변수에 tuple_count[0][0]값을 추가해준다. 이는 위에 말했듯이 맞춘개수가 제일 많은 사람의 이름을 출력하기 위해 넣는 과정이다.
   for 문을 이용해서 동점자가 있을 경우를 계산해본다. 중첩 if문을 이용해 동점이 아닐때는 구문을 빠져나가게 break를 해둔다.
   만약 동점일 경우 answer변수에 tuple_count[i][0]을 추가해준다.
   이로써 다시 answer를 오름차순 정렬해둔다.
   여기서 오름차순 정렬을 다시 하는 이유는 동점자가 여럿일 때는 오름차순 정렬을 하라는 조건이 있기 때문이다.
   다음 answer값을 반환해준다.
   
3. 주의할 점 :
a,b,c 배열의 각각의 길이가 다른 점을 고려하여 a[i % len(a)]를 해주는 것이 중요하고 주의가 필요하다.
   